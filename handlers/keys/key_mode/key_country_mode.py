import asyncio
import uuid

from datetime import datetime
from typing import Any

import pytz

from aiogram import F, Router
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, InlineKeyboardButton, Message
from aiogram.utils.keyboard import InlineKeyboardBuilder
from py3xui import AsyncApi

from config import (
    ADMIN_PASSWORD,
    ADMIN_USERNAME,
    CONNECT_PHONE_BUTTON,
    PUBLIC_LINK,
    RENEWAL_PRICES,
    SUPPORT_CHAT_URL,
    REMNAWAVE_LOGIN,
    REMNAWAVE_PASSWORD
)
from database import (
    add_connection,
    check_connection_exists,
    get_key_details,
    get_trial,
    update_balance,
    update_trial,
    check_server_name_by_cluster,
)
from handlers.buttons import (
    BACK,
    CONNECT_DEVICE,
    CONNECT_PHONE,
    MAIN_MENU,
    PC_BUTTON,
    SUPPORT,
    TV_BUTTON,
    SUPPORT
)
from handlers.keys.key_utils import create_client_on_server
from handlers.texts import (
    SELECT_COUNTRY_MSG,
    key_message_success,
)
from handlers.utils import edit_or_send_message, generate_random_email, get_least_loaded_cluster
from logger import logger
from panels.three_xui import delete_client
from panels.remnawave import RemnawaveAPI


router = Router()

moscow_tz = pytz.timezone("Europe/Moscow")


async def key_country_mode(
    tg_id: int,
    expiry_time: datetime,
    state: FSMContext,
    session: Any,
    message_or_query: Message | CallbackQuery | None = None,
    old_key_name: str = None,
):
    target_message = message_or_query.message if isinstance(message_or_query, CallbackQuery) else message_or_query

    least_loaded_cluster = await get_least_loaded_cluster()
    servers = await session.fetch(
        "SELECT server_name, api_url, panel_type FROM servers WHERE cluster_name = $1",
        least_loaded_cluster,
    )


    if not servers:
        logger.error(f"–ù–µ—Ç —Å–µ—Ä–≤–µ—Ä–æ–≤ –≤ –∫–ª–∞—Å—Ç–µ—Ä–µ {least_loaded_cluster}")
        error_message = "‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–ª—é—á–∞."
        await edit_or_send_message(
            target_message=target_message,
            text=error_message,
            reply_markup=None,
        )
        return

    available_servers = []
    tasks = [asyncio.create_task(check_server_availability(server)) for server in servers]
    results = await asyncio.gather(*tasks, return_exceptions=True)

    for server, result in zip(servers, results):
        if result is True:
            available_servers.append(server["server_name"])

    if not available_servers:
        logger.error(f"–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤ –≤ –∫–ª–∞—Å—Ç–µ—Ä–µ {least_loaded_cluster}")
        error_message = "‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–ª—é—á–∞."
        await edit_or_send_message(
            target_message=target_message,
            text=error_message,
            reply_markup=None,
        )
        return

    logger.info(f"[Country Selection] –î–æ—Å—Ç—É–ø–Ω—ã–µ —Å–µ—Ä–≤–µ—Ä—ã –¥–ª—è –≤—ã–±–æ—Ä–∞: {available_servers}")

    builder = InlineKeyboardBuilder()
    ts = int(expiry_time.timestamp())

    for country in available_servers:
        if old_key_name:
            callback_data = f"select_country|{country}|{ts}|{old_key_name}"
        else:
            callback_data = f"select_country|{country}|{ts}"
        builder.row(InlineKeyboardButton(text=country, callback_data=callback_data))

    builder.row(InlineKeyboardButton(text=MAIN_MENU, callback_data="profile"))

    await edit_or_send_message(
        target_message=target_message,
        text=SELECT_COUNTRY_MSG,
        reply_markup=builder.as_markup(),
        media_path=None,
    )


@router.callback_query(F.data.startswith("change_location|"))
async def change_location_callback(callback_query: CallbackQuery, session: Any):
    try:
        data = callback_query.data.split("|")
        if len(data) < 2:
            await callback_query.answer("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ", show_alert=True)
            return

        old_key_name = data[1]
        record = await get_key_details(old_key_name, session)
        if not record:
            await callback_query.answer("‚ùå –ö–ª—é—á –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
            return

        expiry_timestamp = record["expiry_time"]
        ts = int(expiry_timestamp / 1000)

        current_server = record["server_id"]

        cluster_info = await check_server_name_by_cluster(current_server, session)
        if not cluster_info:
            await callback_query.answer("‚ùå –ö–ª–∞—Å—Ç–µ—Ä –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
            return

        cluster_name = cluster_info["cluster_name"]

        servers = await session.fetch(
            "SELECT server_name, api_url, panel_type FROM servers WHERE cluster_name = $1 AND server_name != $2",
            cluster_name,
            current_server,
        )
        if not servers:
            await callback_query.answer("‚ùå –î–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤ –≤ –∫–ª–∞—Å—Ç–µ—Ä–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", show_alert=True)
            return

        available_servers = []
        tasks = []

        for server in servers:
            server_info = {
                "server_name": server["server_name"],
                "api_url": server["api_url"],
                "panel_type": server["panel_type"],
            }
            task = asyncio.create_task(check_server_availability(server_info))
            tasks.append(task)

        results = await asyncio.gather(*tasks, return_exceptions=True)

        for server, result in zip(servers, results):
            if result is True:
                available_servers.append(server["server_name"])

        if not available_servers:
            await callback_query.answer("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤ –¥–ª—è —Å–º–µ–Ω—ã –ª–æ–∫–∞—Ü–∏–∏", show_alert=True)
            return

        logger.info(f"–î–æ—Å—Ç—É–ø–Ω—ã–µ —Å—Ç—Ä–∞–Ω—ã –¥–ª—è —Å–º–µ–Ω—ã –ª–æ–∫–∞—Ü–∏–∏: {available_servers}")

        builder = InlineKeyboardBuilder()
        for country in available_servers:
            callback_data = f"select_country|{country}|{ts}|{old_key_name}"
            builder.row(InlineKeyboardButton(text=country, callback_data=callback_data))
        builder.row(InlineKeyboardButton(text=BACK, callback_data=f"view_key|{old_key_name}"))

        await edit_or_send_message(
            target_message=callback_query.message,
            text="üåç –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–≤—É—é –ª–æ–∫–∞—Ü–∏—é –¥–ª—è –≤–∞—à–µ–π –ø–æ–¥–ø–∏—Å–∫–∏:",
            reply_markup=builder.as_markup(),
            media_path=None,
        )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–º–µ–Ω–µ –ª–æ–∫–∞—Ü–∏–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {callback_query.from_user.id}: {e}")
        await callback_query.answer("‚ùå –û—à–∏–±–∫–∞ —Å–º–µ–Ω—ã –ª–æ–∫–∞—Ü–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.", show_alert=True)


@router.callback_query(F.data.startswith("select_country|"))
async def handle_country_selection(callback_query: CallbackQuery, session: Any, state: FSMContext):
    """
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—ã–±–æ—Ä —Å—Ç—Ä–∞–Ω—ã.
    –§–æ—Ä–º–∞—Ç callback data:
      select_country|{selected_country}|{ts} [|{old_key_name} (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)]
    –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω old_key_name ‚Äì –∑–Ω–∞—á–∏—Ç, –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Å–º–µ–Ω–∞ –ª–æ–∫–∞—Ü–∏–∏.
    """
    data = callback_query.data.split("|")
    if len(data) < 3:
        await callback_query.message.answer("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return

    selected_country = data[1]
    try:
        ts = int(data[2])
    except ValueError:
        await callback_query.message.answer("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –≤—Ä–µ–º—è –∏—Å—Ç–µ—á–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return

    expiry_time = datetime.fromtimestamp(ts, tz=moscow_tz)

    old_key_name = data[3] if len(data) > 3 else None

    tg_id = callback_query.from_user.id
    logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {tg_id} –≤—ã–±—Ä–∞–ª —Å—Ç—Ä–∞–Ω—É: {selected_country}")
    logger.info(f"–ü–æ–ª—É—á–µ–Ω–æ –≤—Ä–µ–º—è –∏—Å—Ç–µ—á–µ–Ω–∏—è (timestamp): {ts}")

    await finalize_key_creation(tg_id, expiry_time, selected_country, state, session, callback_query, old_key_name)


async def finalize_key_creation(
    tg_id: int,
    expiry_time: datetime,
    selected_country: str,
    state: FSMContext | None,
    session: Any,
    callback_query: CallbackQuery,
    old_key_name: str = None,
):
    if not await check_connection_exists(tg_id):
        await add_connection(tg_id, balance=0.0, trial=0, session=session)
        logger.info(f"[Connection] –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {tg_id}")

    expiry_time = expiry_time.astimezone(moscow_tz)

    if old_key_name:
        old_key_details = await get_key_details(old_key_name, session)
        if not old_key_details:
            await callback_query.message.answer("‚ùå –ö–ª—é—á –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
            return

        key_name = old_key_name
        client_id = old_key_details["client_id"]
        email = old_key_details["email"]
        expiry_timestamp = old_key_details["expiry_time"]
    else:
        while True:
            key_name = generate_random_email()
            existing_key = await get_key_details(key_name, session)
            if not existing_key:
                break
        client_id = str(uuid.uuid4())
        email = key_name.lower()
        expiry_timestamp = int(expiry_time.timestamp() * 1000)

    try:
        server_info = await session.fetchrow(
            "SELECT api_url, inbound_id, server_name, panel_type FROM servers WHERE server_name = $1",
            selected_country,
        )
        if not server_info:
            raise ValueError(f"–°–µ—Ä–≤–µ—Ä {selected_country} –Ω–µ –Ω–∞–π–¥–µ–Ω.")

        panel_type = server_info["panel_type"].lower()

        public_link = None
        remnawave_link = None
        created_at = int(datetime.now(moscow_tz).timestamp() * 1000)

        if old_key_name and panel_type == "3x-ui":
            old_server_id = old_key_details.get("server_id")
            if old_server_id:
                old_server_info = await session.fetchrow(
                    "SELECT api_url, inbound_id, server_name FROM servers WHERE server_name = $1",
                    old_server_id,
                )
                if old_server_info:
                    xui = AsyncApi(
                        old_server_info["api_url"],
                        username=ADMIN_USERNAME,
                        password=ADMIN_PASSWORD,
                        logger=logger,
                    )
                    await delete_client(
                        xui,
                        old_server_info["inbound_id"],
                        email,
                        client_id,
                    )

        if panel_type == "remnawave":
            remna = RemnawaveAPI(server_info["api_url"])
            logged_in = await remna.login(REMNAWAVE_LOGIN, REMNAWAVE_PASSWORD)
            if not logged_in:
                raise ValueError(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è –≤ Remnawave ({selected_country})")

            expire_at = datetime.utcfromtimestamp(expiry_timestamp / 1000).isoformat() + "Z"
            user_data = {
                "username": email,
                "trafficLimitStrategy": "NO_RESET",
                "expireAt": expire_at,
                "telegramId": tg_id,
                "activeUserInbounds": [server_info["inbound_id"]],
            }
            result = await remna.create_user(user_data)
            if not result:
                raise ValueError("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ Remnawave")

            client_id = result.get("uuid")
            remnawave_link = result.get("subscriptionUrl")
            logger.info(f"[Key Creation] Remnawave –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–æ–∑–¥–∞–Ω: {result}")

        if panel_type == "3x-ui":
            semaphore = asyncio.Semaphore(2)
            await create_client_on_server(
                server_info=server_info,
                tg_id=tg_id,
                client_id=client_id,
                email=email,
                expiry_timestamp=expiry_timestamp,
                semaphore=semaphore,
            )
            public_link = f"{PUBLIC_LINK}{email}/{tg_id}"

        logger.info(f"[Key Creation] –ü–æ–¥–ø–∏—Å–∫–∞ —Å–æ–∑–¥–∞–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {tg_id} –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ {selected_country}")

        if old_key_name:
            await session.execute(
                "UPDATE keys SET server_id = $1 WHERE tg_id = $2 AND email = $3",
                selected_country,
                tg_id,
                old_key_name,
            )
        else:
            await session.execute(
                """
                INSERT INTO keys (tg_id, client_id, email, created_at, expiry_time, key, remnawave_link, server_id)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                """,
                tg_id,
                client_id,
                email,
                created_at,
                expiry_timestamp,
                public_link,
                remnawave_link,
                selected_country,
            )
            data = await state.get_data()
            if data.get("is_trial"):
                trial_status = await get_trial(tg_id, session)
                if trial_status in [0, -1]:
                    await update_trial(tg_id, 1, session)
            if data.get("plan_id"):
                plan_price = RENEWAL_PRICES.get(data["plan_id"])
                await update_balance(tg_id, -plan_price, session)

    except Exception as e:
        logger.error(f"[Key Finalize] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∫–ª—é—á–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {tg_id}: {e}")
        await callback_query.message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–æ–¥–ø–∏—Å–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return

    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text=SUPPORT, url=SUPPORT_CHAT_URL))
    if CONNECT_PHONE_BUTTON:
        builder.row(InlineKeyboardButton(text=CONNECT_PHONE, callback_data=f"connect_phone|{key_name}"))
        builder.row(
            InlineKeyboardButton(text=PC_BUTTON, callback_data=f"connect_pc|{email}"),
            InlineKeyboardButton(text=TV_BUTTON, callback_data=f"connect_tv|{email}"),
        )
    else:
        builder.row(InlineKeyboardButton(text=CONNECT_DEVICE, callback_data=f"connect_device|{key_name}"))

    builder.row(InlineKeyboardButton(text=MAIN_MENU, callback_data="profile"))

    remaining_time = expiry_time - datetime.now(moscow_tz)
    days = remaining_time.days

    link_to_show = public_link or remnawave_link or "–°—Å—ã–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
    key_message_text = key_message_success(link_to_show, f"‚è≥ –û—Å—Ç–∞–ª–æ—Å—å –¥–Ω–µ–π: {days} üìÖ")

    await edit_or_send_message(
        target_message=callback_query.message,
        text=key_message_text,
        reply_markup=builder.as_markup(),
        media_path="img/pic.jpg",
    )

    if state:
        await state.clear()


async def check_server_availability(server_info: dict) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Å–µ—Ä–≤–µ—Ä–∞ (3x-ui –∏–ª–∏ Remnawave).
    """
    panel_type = server_info.get("panel_type", "3x-ui").lower()
    server_name = server_info.get("server_name", "unknown")

    try:
        if panel_type == "remnawave":
            remna = RemnawaveAPI(server_info["api_url"])
            await asyncio.wait_for(remna.login(REMNAWAVE_LOGIN, REMNAWAVE_PASSWORD), timeout=5.0)
            logger.info(f"[Ping] Remnawave —Å–µ—Ä–≤–µ—Ä {server_name} –¥–æ—Å—Ç—É–ø–µ–Ω.")
            return True

        else:
            xui = AsyncApi(
                server_info["api_url"],
                username=ADMIN_USERNAME,
                password=ADMIN_PASSWORD,
                logger=logger,
            )
            await asyncio.wait_for(xui.login(), timeout=5.0)
            logger.info(f"[Ping] 3x-ui —Å–µ—Ä–≤–µ—Ä {server_name} –¥–æ—Å—Ç—É–ø–µ–Ω.")
            return True

    except asyncio.TimeoutError:
        logger.warning(f"[Ping] –°–µ—Ä–≤–µ—Ä {server_name} –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª –≤–æ–≤—Ä–µ–º—è.")
        return False
    except Exception as e:
        logger.warning(f"[Ping] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Å–µ—Ä–≤–µ—Ä–∞ {server_name}: {e}")
        return False

